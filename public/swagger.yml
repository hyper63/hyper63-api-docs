openapi: 3.0.3
info:
  title: hyper63
  description: >
    ![logo](https://hyper63.com/favicon-96x96.png)

    # Welcome to hyper63 

    A service-framework that reduces redundant implementation code while maintaining full observabiliity for strong continuous delivery pipelines.

    hyper63 provides api abstractions to some of the core application building blocks. Using the ports and 
    adapters architecture, hyper63's approach empowers you
    to use the service for each port you prefer.

      * cache 
      * data 
      * storage 
      * search 
      * hooks*

    ## Getting started

    To run the dev version of hyper63 in your local environment, make sure you have nodejs v14 or later installed then run:
    
    
    
        npx @hyper63/x
    
    
    npx is a cli from npm that will download and run an npm package bin file. If you prefer to install then run you can do the following:
    
    
    
        npm install --global @hyper63/x
        npx @hyper63/dev
    
    
    
    When hyper63 is running you will be able access the api service from [http://0.0.0.0:6363](http://0.0.0.0:6363)

    ## Introduction
    
    As humans who like to build, explore and create we often suffer from the challenge and burden of maintaining, updating, and managing our past buildings and creations. This leads to challenges like spending almost 50% of your day to day as a developer managing technical debt. hyper63's mission is to create a service boundary between the common services every application needs and the implementation details of those services. This boundary creates an enormous amount of benefits for a high performing development team. By not having to worry about the implementation details of services, the team can focus on solving problems for the business and dealing with the constant changing of product requirements. [The Developer Coefficient](https://stripe.com/files/reports/the-developer-coefficient.pdf)
    
    
    In short, hyper63 empowers development teams to create fast continous deployment feedback loops, providing high observability, without having to worry about service implementation details.
    
    ## API
    
    hyper63 is a modular system, which means it can have several ways to implement its API gateway as well as its service ports. The most common implementation is as a REST/JSON API, so this document focuses on this gateway implementation.
    
    The API is made of four core services: [data, cache, storage, search] Each service has a series of api endpoints to perform the basic functionality of the given service. Through out this document we will discuss each service in detail and each endpoint in detail. 
    
    ## Authentication

    Each api call will require a JWT or JSONWebToken in order to accept a request, this token is provided in the `Authorization` header as a `Bearer` token. Currently, this token is generated using a library like `jsonwebtoken` and either a public/private key-pair or a shared secret. In order to try some of the endpoints in this openapi specification, you will need a JWT.
    
    > When coding, it is important to think about the implemenation of your api requests and leverage patterns like circuit-breaker and retries in your client requests. Also, pre-check for expiration of the token and get a new token, to reduce un-expected and avoidable errors.
    
    ## Architecture
    
    hyper63 is made of three logical component sections: [core, app, ports]. 
    
    ### Core
    
    The `core` is where everything comes together, it is the controller of the hyper63 engine, its job is to make sure that requests and responses are flowing correctly from the `app` section to the `port` section and vice versa. The core is responsible for publishing notification events to the hooks module so that there is transparent observability within every transaction of the hyper63 system.
    
    ### App
    
    The `app` is the `gateway` of hyper63, it is on the front-lines handling every incoming request and every outgoing response to the clients that leverage these services. The app component can be implemented using different technologies from `REST/JSON`, `GRAPHQL`, `GRPC` to embedded modules. With this documentation we will be leveraging the `REST/JSON` implementation, which is the most common implementation.
    
    ### Ports and Adapters
    
    The `ports` are parsable schema definitions that ensure that the `adapter` implementations use the correct data shape for each service function. Ports provide the boundaries in which each service is defined and the `adapter` creates the specific implementation bridge for various technologies that can provide this service. For example, the `data` port can be implemented using different technologies and provide the same features. This pattern ensures the future-proofing of a service and creates reliability, scalability and resilience.
    
    
    > For more information about the ports and adapters pattern checkout this article: [https://jmgarridopaz.github.io/content/hexagonalarchitecture.html](https://jmgarridopaz.github.io/content/hexagonalarchitecture.html)
    
    
    ## More information

    Checkout the [source code](https://github.com/hyper63/hyper63)

    ## License
    
    hyper63 is open source under the Apache2 license.

  contact:
    url: "https://hyper63.com"
    email: tom@hyper63.com
    name: hyper63
  license:
    name: Apache License 2.0
    url: "https://github.com/hyper63/hyper63/blob/main/LICENSE"
  version: "1.0"
  termsOfService: "https://hyper63.com/termsofuse.text"
servers:
  - description: Development Server
    url: "http://localhost:6363"
paths:
  /:
    get:
      tags: [healthcheck]
      description: >
        # HealthCheck

        Knowing if your service is up or down is very important, this endpoint
        provides a simple check to determine if hyper63 is running, we use
        this endpoint to monitor the basic health of the hyper63 system.

        
        
        This endpoint returns 200 if the system is 
        healthy and returns 500 if all of the 
        pings for each service did not come back successful

        
      responses:
        "200":
          description: successful health response
          content:
            application/json:
              schema:
                properties:
                  name:
                    description: hyper63
                    type: string
                  services:
                    type: array
                    description: the ports that are implemented with adapters
                    items:
                      type: string

  /cache:
    get:
      description: >

        # Cache API

        The cache api is a document create, read, update and delete implementation on top of a cache system. This api gives developers the same ergonomics as a document database store to create and manage cached documents. 
        
        
        ## Data Cache Example
        
        
        Store a document in the cache when you have stored it in the database and when a user asks to access this document, pull the document from the cache if it exists. This will keep the access traffic on your database server very low and give much needed bandwidth to the write and query functionality instead of consuming the server with needless reads. 
        
        
        
        1. Store/Update Document in Database
        
        2. If successful, store document in cache
        
        3. API requests document, check cache, if available return document
        
        4. If not in cache, return document from database
        
        5. API requests to delete document, if in cache remove document
        
        6. Delete document from database
        
        
        ## Time to live 
        
        
        You can also use the cache to create temporary TTL (Time to live) data objects, that will only be available for a short time then expire, which can be helpful for managing session on the server side of your application.
        
        
        ## Querying the cache
        
        
        When storing the documents in the cache, you can also query the cache using simple pattern matching, this works great for getting a list of documents and performing pagination. 
        
        
        ### Things to consider
        
        
        1. name your cache store with the type of document, contact, post, comment followed by a `-` then your unique identifier
        
        2. when creating your identifier think about the order you want to retrieve your documents in a list, using a time based identififer like a `cuid` can give you sort semantics based on when the document was created, and can easily be reversed.
        
        
        ## Example
        
        
             GET /cache/default/_query?pattern=contact*
             
          
          Returns all of the contact keys in the cache
        
      tags: [cache]
      responses:
        "200":
          description: cache module info
          content:
            application/json:
              schema:
                properties:
                  name:
                    description: name of module
                    type: string
                  version:
                    description: module version
                    type: string
                  stores:
                    description: list of active stores
                    type: array
                    items:
                      type: string
                  status:
                    description: stability of module
                    type: string
                    enum:
                      - stable
                      - unstable
                    default: unstable
  /cache/{name}:
    put:
      description: >

        # Create Cache Store

        A cache store is a prefix for a cache so 
        that all keys can be stored or grouped under
        a common name. This makes it easy to manage
        cached data.

        ## Cache Name Syntax
        
        - lowercase alphanumeric string
        
        - maximum of 10 characters
        
        - dashes allowed; underscores not allowed
        
        - must begin with a letter
        
        
        For example, to create a cache named 'default'
        
        
            PUT /cache/default
        
        It is also important to note that this function is idempotent and can be invoked several times and if the store is already created then it do nothing.

      tags: [cache]
      parameters:
        - name: name
          in: path
          description: (case insensitive) accepts alphanumeric charcters and dash
          required: true
          schema:
            type: string
      responses:
        "201":
          description: successfully created store
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        "500":
          description: >
            getting a 500 is more than likely a name 
            validation error or the service is not 
            available. In the event of a name validation
            error, be sure to check the message to 
            determine what is invalid about your 
            cache name.
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string
    delete:
      description: >
        # Delete Cache Store

        This function deletes a cache store and removes all
        keys that were a part of this store. Once a store
        is delete it will be impossible to recover the cache
        data, so make sure you use this function with great
        care.
        
        
        ## Example
        
            DELETE /cache/default?confirm=true
            
        The confirm query flag is used to make sure that the intention is valid.
        
      tags: [cache]
      parameters:
        - name: name
          in: path
          description: name of cache store
          required: true
          schema:
            type: string
        - name: confirm
          in: query
          description: flag to confirm deletion
          required: true
          schema:
            type: boolean
      responses:
        "200":
          description: successfully deleted store
          content:
            application/json:
              schema:
                properties:
                  ok: 
                    type: boolean
        "500":
          description: in order to delete store you must confirm
          content:
            application/json:
              schema:
                properties:
                  ok: 
                    type: boolean
                  msg:
                    type: string
    post:
      description: >

        # Create Cache Document
        
        Use this endpoint to create a key value pair in your cache, the key is the unique identifier and the value is the JSON document you would like to store in the cache. You can also include a `ttl` property to specify how long you would like your cache item to exist in the store, if you do not include `ttl` the default is to store the item as long as possible.


        This cache service accepts JSON documents, it is worth
        noting that a number, string, array are all valid json
        documents. 


        When storing a document to the cache, you will want to 
        give it a key, this is how you will recall your document
        from the cache. You also have the option to add a `ttl` 
        property, or time to live, which lets the cache know 
        how long to keep the value in the cache. The ttl property 
        takes values like `1m`  one minute, `2h` two hours, `3d` three days.

        ## Key Syntax
        
        - lowercase alphanumeric string
        
        - maximum of 10 characters
        
        - dashes allowed; underscores not allowed
        
        - must begin with a letter

        ## Example
        
            POST /cache/default
            Content-Type: application/json
            
            {
              "key": "hello-world",
              "value": {
                "name": "Earth",
                "type": "Planet",
                "date": "2020-12-24"
              }
            }
            
        
      tags: [cache]
      parameters:
        - name: name
          in: path
          description: name of cache store
          required: true
          schema:
            type: string
      requestBody:
        description: cache document
        required: true
        content:
          application/json:
            schema:
              properties:
                key:
                  type: string
                value:
                  type: object
                ttl:
                  type: string
      responses:
        "201":
          description: successfully create cache doc
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: true
                  doc:
                    type: object
        "500":
          description: internal error occured
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string
  "/cache/{name}/_query":
    get:
      description: >
        
        # Query your cache
        
        Using a pattern match string you can request one or more keys from your cache in a batch request. 
        
            GET /cache/default/_query?pattern=widget*
            
            
        or
        
            GET /cache/default/_query?pattern=*something*
            
        
        ## Syntax
        
        1. `*` asterisk is a wildcard that represents one to many characters
        
        
      tags: [cache]
      parameters:
        - name: name
          in: path
          description: name of cache store
          required: true
          schema:
            type: string
        - name: pattern
          in: query
          description: pattern to match keys
          required: false
          schema:
            type: string
      responses:
        "200":
          description: successfully responde with list of docs
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: true
                  docs:
                    type: array
                    items:
                      type: object
        "500":
          description: error occured with query
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string
  "/cache/{name}/{key}":
    get:
      description: get cache key from store
      tags: [cache]
      parameters:
        - name: name
          in: path
          schema:
            type: string
          required: true
        - name: key
          in: path
          schema:
            type: string
          required: true
      responses:
        "200":
          description: successful response
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: true
                  doc:
                    type: object
        "500":
          description: error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string
    put:
      description: update cache document
      tags: [cache]
      parameters:
        - name: name
          in: path
          schema:
            type: string
          required: true
        - name: key
          in: path
          schema:
            type: string
          description: cache document
          required: true
        - name: ttl
          in: query
          schema:
            type: string
          required: false
      requestBody:
        content:
          application/json:
            schema:
              type: object
      responses:
        "200":
          description: successfully create cache doc
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: true
                  doc:
                    type: object
        "500":
          description: internal error occured
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string
    delete:
      description: remove cache document
      tags: [cache]
      parameters:
        - name: name
          in: path
          required: true
          schema:
            type: string
        - name: key
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: successfully create cache doc
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: true
                  doc:
                    type: object
        "500":
          description: internal error occured
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                    default: false
                  msg:
                    type: string

  /data:
    get:
      description: >
        # default data port endpoint

        This endpoint provides the current data adapter 
        name and version information.

      tags: [data]
      responses:
        "200":
          description: data module info
          content:
            application/json:
              schema:
                properties:
                  name:
                    description: module name
                    type: string
        "500":
          description: service not available
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
  /data/{name}:
    get:
      description: >
        # List Documents

        Get all documents in the database using optional filter parameters

        * __keys__ - a comma separated list of document ids

        * __limit__ - the amount of documents to return    

        * __startkey__ - a partial id to start matching keys  

        * __endkey__ - a partial id to end matching keys    

        ## Use Cases

        ### Getting document details from a cache

        Storing keys with specific
        data in a cache can create fast queries, often you will want to 
        retrieve all the document details of those keys in a single request
        this endpoint can be used with the keys query param to get a set
        of documents based on their key/id.

        ### Pagination

        Using startkey and limit, you can create a simple pagination workflow
        getting the next x documents.

        ### Autocomplete with structured keys

        Using structured or smart keys, you can turn the key into 
        a dynamic index and leverage the startkey and endkey as a
        easy to use autocomplete feature for a specific dataset.

      tags: [data]
      parameters:
        - name: name
          in: path
          description: list documents
          required: true
          schema:
            type: string
        - name: keys
          in: query
          description: get documens by keys
          required: false
          schema:
            type: string
        - name: limit
          in: query
          description: number of documents to return
          required: false
          schema:
            type: string
        - name: startkey
          in: query
          description: startkey of range of docs
          required: false
          schema:
            type: string
        - name: endkey
          in: query
          description: endkey of range of docs
          required: false
          schema:
            type: string
        - name: descending
          in: query
          description: sort keys in descending order
          required: false
          schema:
            type: string
      responses:
        "200":
          description: success
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  docs:
                    type: array
                    items:
                      type: object
                      properties:
                        id:
                          type: string
                      additionalProperties: true
        "500":
          description: error occured
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string

    put:
      description: >
        # Create DataStore

        Create a datastore to contain json documents, the data
        store is schemaless, so it can contain multiple documents
        of different shape and type, it is up to the developer
        to manange the schema and rules of the data at the business
        logic tier.

        The datastore {name} must be composed by the following rules:

        * __name__ must begin with a lowercase letter (a-z)

        * Lowercase characters (a-z)

        * Digits (0-9)

        * Any of the characters `_` `$` `+` `-`

        > Regular Expression: `^[a-z][a-z0-9_$+/-]*$`

      tags: [data]
      parameters:
        - name: name
          in: path
          description: name of database
          required: true
          schema:
            type: string
      responses:
        "201":
          description: successfully created database
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        "500":
          description: error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
    delete:
      description: >
        # Destroy Datastore

        Permenately Delete the database and all the content in the
        database.

        > WARNING: Use with caution!
      tags: [data]
      parameters:
        - name: name
          in: path
          description: name of database
          required: true
          schema:
            type: string
      responses:
        "200":
          description: successfully removed database
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        "500":
          description: could not remove database
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
    post:
      description: >
        # Create Document

        This command inserts a json document into the data store

        ### RECOMMENDATIONS:

        * Create your own unique `id` property, either by concation of unique data elements or with ISO date timestmp and prefex or suffix

        * Use the `type` property to classify your document

        * Document the `user` and `date` the record is being created for audit purposes

      tags: [data]
      parameters:
        - name: name
          in: path
          description: name of database
          required: true
          schema:
            type: string
      requestBody:
        description: json body that requires submitting
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                id:
                  type: string
                type:
                  type: string
      responses:
        "201":
          description: successfully created document
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  id:
                    type: string
        "500":
          description: server error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
  /data/{name}/_index:
    post:
      description: >
        # Create Query Index

        In order to create fast and performant queries, it is recommended
        to create an index.

        ## Basic Index Attribures

        * __name__ - the name of your index, this name will be used in the `_query` command to identify the index you want to use.

        * __fields__ - an array of fields that you want to index, order of the fields is very important for the query. For example, if you are indexing `['type', 'name']` then when you query the database, you want to specify type first then name.

      tags: [data]
      parameters:
        - name: name
          in: path
          required: true
          description: name of database
          schema:
            type: string
      requestBody:
        description: index document
        required: true
        content:
          application/json:
            schema:
              properties:
                name:
                  type: string
                fields:
                  type: array
                  items:
                    type: string
      responses:
        "201":
          description: success
  /data/{name}/_query:
    post:
      description: >
        # Query Database

        hyper63 uses a declarative JSON querying syntax. 

        ``` json
        "query" {
          "selector": {
            "type": "movie",
            "year": { "$gte": "2000"}
          },
          "fields": "title",
          "sort": [{"year": "asc"}],
          use_index: "idx-name"
        }

        ```

        ## Basics

        The selector object lets you specify one or more fields

        You can create more complex selector expressions by combining operators. `$eq`, `$gt`, `$gte`, `$lt`, `$lte`, etc

        > TODO: Create documentation for all allowed operators

      tags: [data]
      parameters:
        - name: name
          in: path
          required: true
          description: name of database
          schema:
            type: string
      requestBody:
        description: json query document
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        "201":
          description: successful result
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  docs:
                    type: array
        "500":
          description: error trying to run query
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string

  /data/{name}/{id}:
    get:
      description: >
        # Get Document

        To quickly return a single document, 
        simply provide the name of the data store
        and the document id.

      tags: [data]
      parameters:
        - name: name
          in: path
          required: true
          description: database name
          schema:
            type: string
        - name: id
          in: path
          description: document id
          required: true
          schema:
            type: string
      responses:
        "200":
          description: get document
          content:
            application/json:
              schema:
                type: object
        "500":
          description: server error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
    put:
      description: >
        # Update Document

        To update/modify the document, use this method
        to put an entirely new document in the store with 
        the specified id. Note this will replace the 
        currently stored document.

      tags: [data]
      parameters:
        - name: name
          in: path
          description: database name
          required: true
          schema:
            type: string
        - name: id
          in: path
          description: document id
          required: true
          schema:
            type: string
      requestBody:
        description: json body that requires submitting
        required: true
        content:
          application/json:
            schema:
              type: object
      responses:
        "201":
          description: update document
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  id:
                    type: string
        "500":
          description: error updating document
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
    delete:
      description: >
        # Delete document

        Removes the specified document from the datastore.

      tags: [data]
      parameters:
        - name: name
          in: path
          description: database name
          required: true
          schema:
            type: string
        - name: id
          description: document id
          in: path
          required: true
          schema:
            type: string
      responses:
        "201":
          description: deleted document
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  id:
                    type: string
        "500":
          description: error trying to delete document
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  id:
                    type: string

  
  
  /storage:
    get:
      description: storage module healthcheck
      tags: [storage]
      responses:
        200:
          description: healthcheck json
          content:
            application/json:
              schema:
                type: object
  /storage/{name}:
    put:
      description: make storage bucket
      tags: [storage]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        201:
          description: success
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        500:
          description: error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
    delete:
      description: remove storage bucket - all items must be removed
      tags: [storage]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        201:
          description: success
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        500:
          description: error
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string

    post:
      description: upload file to storage
      tags: [storage]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      requestBody:
        description: placeholder
        content:
          multipart/form-data:
            schema:
              required:
                - file
              properties:
                file:
                  description: form-data file buffer
                  type: object
                path:
                  description: path to store file
                  type: string
      responses:
        201:
          description: successful upload
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
        500:
          description: error with upload
          content:
            application/json:
              schema:
                properties:
                  ok:
                    type: boolean
                  msg:
                    type: string
  /storage/{name}/_list:
    get:
      description: list items in storage bucket
      tags: [storage]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        200:
          description: get list of items in bucket
  /storage/{name}/{object}:
    get:
      description: download file from storage
      tags: [storage]
      parameters:
        - in: path
          description: storage bucket name
          required: true
          name: name
          schema:
            type: string
        - in: path
          description: object path and name
          required: true
          name: object
          schema:
            type: string
      responses:
        200:
          description: returns object
    delete:
      description: delete file from storage
      tags: [storage]
      parameters:
        - in: path
          description: storage bucket name
          required: true
          name: name
          schema:
            type: string
        - in: path
          description: object path and name
          required: true
          name: object
          schema:
            type: string
      responses:
        200:
          description: delete object
  /search:
    get:
      description: >
        # hyper63 Search Service

        Welcome to the search service, this api allows you
        to easily create search index for your application.

        A search service creates and inverted index of your json
        documents, so that you can quickly access search results
        to give your application's business logic fast access to
        information.

        ## Search Indexes

        Search indexes are logical groups of documents you want to 
        search. For each unique search you will want to create an
        index, this allows you to manage that group of documents 
        separately from other groups of documents.

        creating an index store

        * PUT /search/:index - create index

        removing an index store

        * DELETE /search/:index - remove index

        ## Search Documentsd

        Search documents are json documents that contain properties that
        you want to index and search from and the data you want to retrieve
        from the search results.

        Using standard crud rest commands your manage your search documents

        * POST /search/:index - create search doc ({key, doc})  

        * GET /search/:index/:key - get search doc 

        * PUT /search/:index/:key - update search doc 

        * DELETE /search/:index/:key - delete search doc

        ## Executing Search

        Now that you have all of your search documents in your index
        now you can query those documents using a query document

        * POST /search/:index/_query

      tags: [search]
      responses:
        200:
          description: success

  /search/{name}:
    put:
      description: >
        # Create Search Index

        A search index is a logical group of document types
        that focus on consistent search results to return to
        your business logic.


        Examples:

          If your app needs to search movies, you may want to 
          create an index called movies.
          
          If you have an app that needs to search for a given
          set of documents per account and you want to create
          a highlevel filter for each account, then maybe 
          create an index per account.
          
          With the ability to create indexes you will have
          the ability to name them in a referencable way.
          
          When naming the index be sure not to create name
          with non numeric characters or spaces. A name can
          contain a `-` but must not have any spaces or any 
          other non alphanumeric characters.
          
          ### Search Index Mapping
          
          By default, the search service will try to take the
          shape of the json document and determine the types
          of each property, but sometimes, you need to describe
          the specific type of the property. A good example is
          a movie document:
          
          
          ```
          {
            "title": "Star Wars",
            "year": 1978
          }
          ```
          
          In this document, the search service will think that
          the year property is a number and will index based
          on that fact, but your app may want it to be reconized as
          a date so that you can run queries with date filters.
          
          
          In this case, you will need a mapping document when 
          creating the index. 
          
          ```
          {
            "properties": {
              "year": "date"
            }
          }
          ```
          
          This mapping document lets the search service treat the
          year property as a date not a number.

          > Using minisearch your mapping object would be slightly different

          ```
          {
            "fields": ["title", "year",
            "storeFields": ["title", "year"]
          }
          ```

      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        201:
          description: created search index
    delete:
      description: >
        # Delete Search Index

        By deleting a search index it will remove all search 
        documents and search indexes created.
      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        200:
          description: deleted search index
    post:
      description: >
        # Create Search Document for a given Index

        Once you have created your index, you can start to add
        search documents using the POST method with a request 
        containing a body of the following shape:


        ```

        {
          key: 'unique identifier',
          doc: 'search document'
        }

        ```     


        You will need to specify the key you want your document to be
        referenced by and then the search document a json document that
        you want to search.

      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        201:
          description: successfully indexed document

  /search/{name}/{key}:
    get:
      description: >
        # Get Search Document

        This request will return the search document
        in the specified search index and key.

      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
        - in: path
          required: true
          name: key
          schema:
            type: string
      responses:
        200:
          description: successfully got document
    put:
      description: >
        # Update search index

        Over time a search data for a document may change and
        you will want to update a specific document with new
        search criteria, using this `PUT` request, you can 
        update the document with search.

      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
        - in: path
          required: true
          name: key
          schema:
            type: string
      responses:
        200:
          description: success
    delete:
      description: remove index document
      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
        - in: path
          required: true
          name: key
          schema:
            type: string
      responses:
        200:
          description: success remove document
  /search/{name}/_bulk:
    post:
      description: >
        # Batch Search Documents

        You may have a large list of documents you want to 
        search in your application, like movies or addresses

        This request endpoint lets you send a json array of 
        search documents and the search service will bulk load
        the documents into the search index.

        This endpoint is currently not operational, but should
        be created soon.

      tags: [search]
      parameters:
        - in: path
          name: name
          required: true
          schema:
            type: string
      responses:
        201:
          description: success
  /search/{name}/_query:
    get:
      description: >
        # Query an index

        Querying documents on a given index is the core
        feature of the search service, using this endpoint
        you can create a query json document to retrieve
        documents quickly in the search index.

        ### Search all Docs

        ```

        {
          "query": {
            "match_all": {}
          }
        }

        ```

        ### Search title which contains foo

        ```

        {
          "query": {
            "match": {
              "title": "foo"
            }
          }
        }

        ```

        ### Filter by a term

        ```

        {
          "query": {
            "filter": {
              "term": {
                "status": "active"
              } 
            }
          }
        }

        ```

        Use filter to return docs that have a status of active

        ---

        ## Using MiniSearch Adapter

        > If you are using the MiniSearch adapter you don't get all the search options

        ```
        {
          "query": "[enter search string here]"
        }
        ```

      tags: [search]
      parameters:
        - in: path
          required: true
          name: name
          schema:
            type: string
      responses:
        200:
          description: success
